// function OTP() {

//    let otp=[Math.floor(Math.random()*10000)]
//     console.log(otp)
   
//   }
//   OTP()

//   // isNaN(123): returns false because 123 is a number.
//   // isNaN(-1.23): returns false because -1.23 is a number.
//   // isNaN(NaN): returns true because the value is NaN.
//   // 2. Non-numeric
//   // isNaN("123"): returns false because the string "123" can be converted to a number.
//   // isNaN("Hello"): returns true because the string "Hello" cannot be converted to a number.
//   // isNaN(""): returns false because an empty string is coerced to 0, which is a number.
//   // isNaN(true): returns false because true is coerced to 1, which is a number.
//   // isNaN(false): returns false because false is coerced to 0, which is a number.
//   // isNaN(undefined): returns true because undefined cannot be converted to a number.
//   // isNaN(null): returns false because null is coerced to 0, which is a number.
//   // 3. Objects
//   // isNaN({}): returns true because an object cannot be converted to a number.
//   // isNaN([]): returns false because an empty array is coerced to 0, which is a number.
//   // isNaN([1, 2, 3]): returns true because an array with more than one element cannot be converted to a single number.
//   // 4. Using Number.isNaN
//   // Number.isNaN is a more reliable method introduced in ECMAScript 2015 (ES6) because it does not perform type coercion.
  
//   // Number.isNaN(123): returns false.
//   // Number.isNaN("123"): returns false.
//   // Number.isNaN(NaN): returns true.
//   // Number.isNaN("Hello"): returns false.
//   // Number.isNaN(undefined): returns false.
//   // Number.isNaN(null): returns false.

// // function add(num){
// //     sum=0
// //     while(num!=0){
// //         rem=num%10;
// //         sum=sum+rem;
// //         num=Math.floor(num/10);
// //     }
// //     if(sum<10){
// //         return sum;
// //     }
// //     return add(sum);    
// // }
// // console.log(add(999999))




// // let k=Math.pow("HELLO",3)
// // console.log(k)




